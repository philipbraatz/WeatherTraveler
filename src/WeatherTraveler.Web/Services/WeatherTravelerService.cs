using System.Collections.Generic;
using Microsoft.FSharp.Core;
using Microsoft.FSharp.Collections;

namespace WeatherTraveler.Web.Services;

// Create C# wrapper types for F# types
public class WeatherInfo
{
    public double Temperature { get; set; }
    public WeatherCondition Condition { get            var kml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                     "<kml xmlns=\"http://www.opengis.net/kml/2.2\">\n" +
                     "  <Document>\n" +
                     "    <name>Weather Traveler Route</name>\n" +
                     $"    <description>Travel route generated by Weather Traveler on {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC</description>\n" +
                     "    <Style id=\"routeStyle\">\n" +
                     "      <LineStyle>\n" +
                     "        <color>ff0000ff</color>\n" +
                     "        <width>3</width>\n" +
                     "      </LineStyle>\n" +
                     "    </Style>\n"   public int Humidity { get; set; }
    public double WindSpeed { get; set; }
    public DateTime Timestamp { get; set; }
    public required Coordinate Location { get; set; }
}

public class Coordinate
{
    public double Latitude { get; set; }
    public double Longitude { get; set; }

    public Coordinate() { }
    public Coordinate(double latitude, double longitude)
    {
        Latitude = latitude;
        Longitude = longitude;
    }
}

public class TemperatureRange
{
    public double MinCelsius { get; set; }
    public double MaxCelsius { get; set; }

    public TemperatureRange() { }
    public TemperatureRange(double minCelsius, double maxCelsius)
    {
        MinCelsius = minCelsius;
        MaxCelsius = maxCelsius;
    }
}

public class UserProfile
{
    public string Name { get; set; } = string.Empty;
    public DateTime CreatedDate { get; set; }
    public DateTime LastUpdated { get; set; }
    public UserPreferences Preferences { get; set; } = new();

    public UserProfile() { }
    
    public UserProfile(string name, DateTime createdDate, DateTime lastUpdated, UserPreferences preferences)
    {
        Name = name;
        CreatedDate = createdDate;
        LastUpdated = lastUpdated;
        Preferences = preferences;
    }
}

public class UserPreferences
{
    public TemperatureRange TemperatureRange { get; set; } = new();
    public bool AvoidRain { get; set; }
    public int MaxDrivingHours { get; set; }
    public TimeSpan PreferredDepartureTime { get; set; }
    public FuelType FuelType { get; set; }
    public NotificationSettings Notifications { get; set; } = new();

    public UserPreferences() { }
    
    public UserPreferences(TemperatureRange temperatureRange, bool avoidRain, int maxDrivingHours, 
        TimeSpan preferredDepartureTime, FuelType fuelType, NotificationSettings notifications)
    {
        TemperatureRange = temperatureRange;
        AvoidRain = avoidRain;
        MaxDrivingHours = maxDrivingHours;
        PreferredDepartureTime = preferredDepartureTime;
        FuelType = fuelType;
        Notifications = notifications;
    }
}

public class NotificationSettings
{
    public bool WeatherAlerts { get; set; }
    public bool PriceAlerts { get; set; }
    public bool RouteUpdates { get; set; }

    public NotificationSettings() { }
    public NotificationSettings(bool weatherAlerts, bool priceAlerts, bool routeUpdates)
    {
        WeatherAlerts = weatherAlerts;
        PriceAlerts = priceAlerts;
        RouteUpdates = routeUpdates;
    }
}

public enum FuelType
{
    Regular,
    Plus,
    Premium,
    Diesel,
    Electric,
    Hybrid
}

public enum WeatherCondition
{
    Sunny,
    PartlyCloudy,
    Cloudy,
    Rainy,
    Stormy,
    Snowy,
    Foggy
}

public class GasStationInfo
{
    public string StationName { get; set; } = string.Empty;
    public double Price { get; set; }
    public double Distance { get; set; }
    public Coordinate Location { get; set; } = new();
}

public interface IWeatherTravelerService
{
    Task<WeatherInfo?> GetCurrentWeatherAsync(Coordinate coordinate);
    Task<List<WeatherInfo>> GetWeatherForecastAsync(Coordinate coordinate);
    Task<UserProfile> LoadUserProfileAsync();
    Task SaveUserProfileAsync(UserProfile profile);
    Task<List<WeatherInfo>> PlanRouteAsync(List<Coordinate> waypoints, TemperatureRange temperatureRange);
    Task<double> CalculateDistanceAsync(Coordinate from, Coordinate to);
    Task<List<Coordinate>> GetMajorCitiesAsync();
    Task<string> ExportRouteToKmlAsync(List<Coordinate> waypoints);
    Task<GasStationInfo[]> GetGasPricesAsync(Coordinate location, double radiusKm);
}

public class WeatherTravelerService : IWeatherTravelerService
{
    private static UserProfile? _cachedUserProfile;
    private readonly Random _random = new();

    public async Task<WeatherInfo?> GetCurrentWeatherAsync(Coordinate coordinate)
    {
        try
        {
            await Task.Delay(100);
            
            return new WeatherInfo
            {
                Temperature = 15 + _random.NextDouble() * 20,
                Condition = GetRandomCondition(),
                Humidity = 30 + _random.Next(50),
                WindSpeed = _random.NextDouble() * 20,
                Timestamp = DateTime.UtcNow,
                Location = coordinate
            };
        }
        catch (Exception)
        {
            return null;
        }
    }

    public async Task<List<WeatherInfo>> GetWeatherForecastAsync(Coordinate coordinate)
    {
        try
        {
            await Task.Delay(200);
            
            var forecast = new List<WeatherInfo>();
            var baseTemp = 15 + _random.NextDouble() * 15;
            
            for (int i = 0; i < 5; i++)
            {
                forecast.Add(new WeatherInfo
                {
                    Temperature = baseTemp + (_random.NextDouble() * 10 - 5),
                    Condition = GetRandomCondition(),
                    Humidity = 30 + _random.Next(50),
                    WindSpeed = _random.NextDouble() * 25,
                    Timestamp = DateTime.UtcNow.AddDays(i),
                    Location = coordinate
                });
            }
            
            return forecast;
        }
        catch (Exception)
        {
            return new List<WeatherInfo>();
        }
    }

    public async Task<UserProfile> LoadUserProfileAsync()
    {
        try
        {
            await Task.Delay(100);
            return _cachedUserProfile ?? CreateDefaultUserProfile();
        }
        catch (Exception)
        {
            return CreateDefaultUserProfile();
        }
    }

    public async Task SaveUserProfileAsync(UserProfile profile)
    {
        try
        {
            await Task.Delay(150);
            profile.LastUpdated = DateTime.UtcNow;
            _cachedUserProfile = profile;
            Console.WriteLine($"User profile saved successfully for {profile.Name}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving user profile: {ex.Message}");
            throw;
        }
    }

    public async Task<List<WeatherInfo>> PlanRouteAsync(List<Coordinate> waypoints, TemperatureRange temperatureRange)
    {
        try
        {
            var weatherData = new List<WeatherInfo>();
            
            foreach (var waypoint in waypoints)
            {
                var weather = await GetCurrentWeatherAsync(waypoint);
                if (weather != null)
                {
                    weatherData.Add(weather);
                }
            }
            
            return weatherData;
        }
        catch (Exception)
        {
            return new List<WeatherInfo>();
        }
    }

    public async Task<double> CalculateDistanceAsync(Coordinate from, Coordinate to)
    {
        await Task.Delay(10);
        
        const double R = 6371;
        
        var lat1Rad = from.Latitude * Math.PI / 180;
        var lat2Rad = to.Latitude * Math.PI / 180;
        var deltaLatRad = (to.Latitude - from.Latitude) * Math.PI / 180;
        var deltaLonRad = (to.Longitude - from.Longitude) * Math.PI / 180;

        var a = Math.Sin(deltaLatRad / 2) * Math.Sin(deltaLatRad / 2) +
                Math.Cos(lat1Rad) * Math.Cos(lat2Rad) *
                Math.Sin(deltaLonRad / 2) * Math.Sin(deltaLonRad / 2);
        var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));

        return R * c;
    }

    public async Task<List<Coordinate>> GetMajorCitiesAsync()
    {
        await Task.Delay(50);
        
        return new List<Coordinate>
        {
            new(40.7128, -74.0060),  // New York
            new(34.0522, -118.2437), // Los Angeles
            new(41.8781, -87.6298),  // Chicago
            new(29.7604, -95.3698),  // Houston
            new(33.4484, -112.0740), // Phoenix
            new(39.9526, -75.1652),  // Philadelphia
            new(29.4241, -98.4936),  // San Antonio
            new(32.7157, -117.1611), // San Diego
            new(32.7767, -96.7970),  // Dallas
            new(37.3382, -121.8863), // San Jose
            new(30.2672, -97.7431),  // Austin
            new(30.3322, -81.6557)   // Jacksonville
        };
    }

    public async Task<string> ExportRouteToKmlAsync(List<Coordinate> waypoints)
    {
        try
        {
            await Task.Delay(100);
            
            if (!waypoints.Any())
            {
                Console.WriteLine("ExportRouteToKmlAsync: No waypoints provided");
                return string.Empty;
            }
            
            var coordinateString = string.Join(" ", waypoints.Select(w => $"{w.Longitude:F6},{w.Latitude:F6},0"));
            Console.WriteLine($"ExportRouteToKmlAsync: Generated coordinate string: {coordinateString}");
            
            var kml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                     "<kml xmlns=\"http://www.opengis.net/kml/2.2\">\n" +
                     "  <Document>\n" +
                     "    <name>Weather Traveler Route</name>\n" +
                     $"    <description>Travel route generated by Weather Traveler on {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC</description>\n" +
                     "    <Style id=\"routeStyle\">\n" +
                     "      <LineStyle>\n" +
                     "        <color>ff0000ff</color>\n" +
                     "        <width>3</width>\n" +
                     "      </LineStyle>\n" +
                     "    </Style>\n" +
                     "    <Style id=\"waypointStyle\">\n" +
                     "      <IconStyle>\n" +
                     "        <color>ff00ff00</color>\n" +
                     "        <scale>1.2</scale>\n" +
                     "      </IconStyle>\n" +
                     "    </Style>\n" +
                     "    <Placemark>\n" +
                     $"      <name>Travel Route ({waypoints.Count} waypoints)</name>\n" +
                     "      <description>Planned route with weather considerations</description>\n" +
                     "      <styleUrl>#routeStyle</styleUrl>\n" +
                     "      <LineString>\n" +
                     "        <tessellate>1</tessellate>\n" +
                     "        <coordinates>\n" +
                     $"          {coordinateString}\n" +
                     "        </coordinates>\n" +
                     "      </LineString>\n" +
                     "    </Placemark>\n";
            
            // Add individual waypoint placemarks
            for (int i = 0; i < waypoints.Count; i++)
            {
                var waypoint = waypoints[i];
                var waypointName = i == 0 ? "Start" : i == waypoints.Count - 1 ? "End" : $"Waypoint {i}";
                
                kml += "    <Placemark>\n" +
                       $"      <name>{waypointName}</name>\n" +
                       $"      <description>Coordinate: {waypoint.Latitude:F6}, {waypoint.Longitude:F6}</description>\n" +
                       "      <styleUrl>#waypointStyle</styleUrl>\n" +
                       "      <Point>\n" +
                       $"        <coordinates>{waypoint.Longitude:F6},{waypoint.Latitude:F6},0</coordinates>\n" +
                       "      </Point>\n" +
                       "    </Placemark>\n";
            }
            
            kml += "  </Document>\n" +
                   "</kml>";
            
            Console.WriteLine($"ExportRouteToKmlAsync: Generated KML length: {kml.Length}");
            Console.WriteLine($"ExportRouteToKmlAsync: KML content preview: {kml.Substring(0, Math.Min(200, kml.Length))}...");
            
            return kml;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating KML: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            return string.Empty;
        }
    }

    public async Task<GasStationInfo[]> GetGasPricesAsync(Coordinate location, double radiusKm)
    {
        try
        {
            await Task.Delay(200);
            
            var stations = new List<GasStationInfo>();
            var stationNames = new[] { "Shell", "BP", "Exxon", "Chevron", "Mobil", "Valero" };
            
            for (int i = 0; i < 6; i++)
            {
                var distance = _random.NextDouble() * radiusKm;
                var price = 3.50 + _random.NextDouble() * 0.50;
                
                stations.Add(new GasStationInfo
                {
                    StationName = stationNames[i % stationNames.Length],
                    Price = price,
                    Distance = distance,
                    Location = new Coordinate(
                        location.Latitude + (_random.NextDouble() - 0.5) * 0.1,
                        location.Longitude + (_random.NextDouble() - 0.5) * 0.1
                    )
                });
            }
            
            return stations.OrderBy(s => s.Price).ToArray();
        }
        catch (Exception)
        {
            return Array.Empty<GasStationInfo>();
        }
    }

    private WeatherCondition GetRandomCondition()
    {
        var conditions = Enum.GetValues<WeatherCondition>();
        return conditions[_random.Next(conditions.Length)];
    }

    private static UserProfile CreateDefaultUserProfile()
    {
        return new UserProfile
        {
            Name = Environment.UserName ?? "Weather Traveler",
            CreatedDate = DateTime.UtcNow.AddMonths(-2),
            LastUpdated = DateTime.UtcNow,
            Preferences = new UserPreferences
            {
                TemperatureRange = new TemperatureRange(15.0, 25.0),
                AvoidRain = true,
                MaxDrivingHours = 8,
                PreferredDepartureTime = new TimeSpan(9, 0, 0),
                FuelType = FuelType.Regular,
                Notifications = new NotificationSettings(true, true, true)
            }
        };
    }
}

// Extension methods for F# interop (when we add it later)
public static class FSharpExtensions
{
    public static FSharpMap<TKey, TValue> ToFSharpMap<TKey, TValue>(this Dictionary<TKey, TValue> dict)
        where TKey : notnull
    {
        var pairs = dict.Select(kvp => Tuple.Create(kvp.Key, kvp.Value));
        return MapModule.OfSeq(pairs);
    }

    public static List<T> ToList<T>(this FSharpList<T> fsharpList)
    {
        return ListModule.ToArray(fsharpList).ToList();
    }
}
